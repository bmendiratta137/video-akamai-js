{"version":3,"sources":["../../../../src/ChromecastConstants.js","../../../../src/AmpCafSenderCaptioning.js","../../../../src/AmpCafSender.js","../../../../src/Chromecast.js","../../../../src/main.js"],"names":["ChromecastConstants","player","captioning","hidden","plugin","_hidden","bind","_this","_tracks","onEditTracksInfoError","autoSelectTrack","track","this","lang","selectTrackByLanguage","mediaSession","media","tracks","filter","_track","value","trackId","activeTrackIds","onEditTracksInfoSuccess","editTracksInfo","tracksInfoRequest","akamai","EventDispatcher","config","PlayState","READY","onRemotePlayerChange","onMediaSession","addEventListener","cast","framework","SessionEventType","MEDIA_SESSION","createElements","amp","Events","loadPlugins","MEDIA_CHANGE","dispatch","container","document","createElement","appendChild","message","className","element","device","castSession","getCastDevice","friendlyName","innerHTML","getLocalizedString","chromecast","launch","localization","getLanguageString","_this2","getString","key","type","mode","plugins","react","def","AMP","PERSISTENT","feature","logger","log","error","event","field","playState","remotePlayer","playerState","toLowerCase","DURATION_CHANGE","duration","CAN_PLAY_THROUGH","SEEKED","MUTE_CHANGE","muted","state","PLAYING","RemotePlayerEventType","ANY_CHANGE","remotePlayerController","removeEventListener","RemotePlayer","currentTime","session","customData","setVolumeLevel","waiting","WAITING","onCastApiAvailable","loadResources","sdk","castContext","CastContext","getInstance","CAST_STATE_CHANGED","onCastStateChanged","setOptions","AutoJoinPolicy","ORIGIN_SCOPED","sessionState","SessionState","busy","getMediaSession","map","source","src","sources","includes","contentId","SESSION_STARTED","ID","AmpCafSender","sender","destroy","GenericMediaMetadata","metadata","chrome","title","Image","poster","subtitle","description","pubDate","toISOString","releaseDate","MediaInfo","mediaInfo","length","index","Track","TrackType","TEXT","forEach","TextTrackType","CAPTIONS","subtype","name","l10n","language","srclang","trackContentId","startTime","catch","Plugin","registerPlugin"],"mappings":"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","file":"akamai/amp/chromecast/Chromecast.min.js","sourcesContent":["export default class ChromecastConstants {\n\n  static get ID() {\n    return \"chromecast\"\n  }\n\n  static get CHANNEL_ID() {\n    return \"urn:x-cast:com.akamai.amp.cast\"\n  }\n\n  static get APPLICATION_ID() {\n    return \"CC1AD845\"\n  }\n\n  static get SUPPORTED_TYPES() {\n    return [\n      akamai.amp.Utils.mimeTypes.m3u8,\n      akamai.amp.Utils.mimeTypes.mp4,\n      akamai.amp.Utils.mimeTypes.mpd,\n      akamai.amp.Utils.mimeTypes.ism,\n      akamai.amp.Utils.mimeTypes.webm,\n      akamai.amp.Utils.mimeTypes.mp3\n    ]\n  }\n}\n","export default class AmpCafSenderCaptioning extends akamai.amp.EventDispatcher {\n\n  constructor(player) {\n    super()\n    this.player = player.player\n    this.plugin = player.plugin\n    this._hidden = this.player.captioning.hidden\n    this._tracks = []\n    this.onEditTracksInfoSuccess = this.onEditTracksInfoSuccess.bind(this)\n    this.onEditTracksInfoError = this.onEditTracksInfoError.bind(this)\n\n    this.autoSelectTrack()\n    this.hidden = this.player.hidden\n  }\n\n  get tracks() {\n    const mediaSession = this.plugin.mediaSession\n    if (mediaSession == null || mediaSession.media == null || mediaSession.media.tracks == null) {\n      return []\n    }\n    return mediaSession.media.tracks.filter((track) => (track.subtype == chrome.cast.media.TextTrackType.CAPTIONS) ? track : null)\n  }\n\n  get track() {\n    return this._track || {}\n  }\n\n  set track(value) {\n    this._track = value\n  }\n\n  get hidden() {\n    return this._hidden\n  }\n\n  set hidden(value) {\n    if (value == this._hidden) {\n      return\n    }\n    this._hidden = value\n\n    const activeTrackIds = (value) ? [] : [this.track.trackId]\n    const tracksInfoRequest = new chrome.cast.media.EditTracksInfoRequest(activeTrackIds)\n    this.plugin.mediaSession.editTracksInfo(tracksInfoRequest, this.onEditTracksInfoSuccess, this.onEditTracksInfoError)\n\n    this.dispatch(\"visibilitychange\", !this._hidden)\n  }\n\n  onEditTracksInfoSuccess(event) {\n\n  }\n\n  onEditTracksInfoError(event) {\n\n  }\n\n  selectTrackByLanguage(lang) {\n    const track = this.tracks.filter((track) => (track.language === lang))[0]\n    if (track != null) {\n      this.track = track\n    }\n    return track\n  }\n\n  changeSettings(obj) {\n\n  }\n\n  autoSelectTrack() {\n    let lang = this.player.language\n    let track = null\n\n    if (lang != null) {\n      lang = lang.split(\"-\").shift()\n      track = this.selectTrackByLanguage(lang)\n    }\n\n    return track\n  }\n}\n","import AmpCafSenderCaptioning from \"./AmpCafSenderCaptioning\"\n\nexport default class AmpCafSender extends akamai.amp.EventDispatcher {\n\n  constructor(plugin) {\n    super()\n    this.player = plugin.player\n    this.config = akamai.amp.Utils.clone(this.player.config)\n    this.plugin = plugin\n    this.state = {\n      playState: akamai.amp.PlayState.READY,\n      waiting: false,\n      seeking: false\n    }\n\n    this.onRemotePlayerChange = this.onRemotePlayerChange.bind(this)\n    this.onMediaSession = this.onMediaSession.bind(this)\n    this.onMediaSession()\n\n    this.plugin.castSession.addEventListener(cast.framework.SessionEventType.MEDIA_SESSION, this.onMediaSession)\n\n    this.createElements()\n    this.loadPlugins()\n      .then(() => {\n        this.dispatch(akamai.amp.Events.READY)\n        this.dispatch(akamai.amp.Events.MEDIA_CHANGE, this.media)\n        this.dispatch(akamai.amp.Events.CAN_PLAY_THROUGH)\n      })\n  }\n\n  createElements() {\n    this.container = document.createElement(\"div\")\n    this.container.className = \"amp-chromecast-sender\"\n    this.player.container.appendChild(this.container)\n\n    this.message = document.createElement(\"div\")\n    this.message.className = \"amp-chromecast-sender-msg\"\n    const element = document.createElement(\"div\")\n    element.className = \"amp-chromecast-sender-text\"\n    element.innerHTML = this.getLocalizedString(\"MSG_CHROMECAST_MESSAGE\", {device: this.plugin.castSession.getCastDevice().friendlyName})\n    this.message.appendChild(element)\n    this.player.container.appendChild(this.message)\n  }\n\n  loadPlugins() {\n    this.chromecast = {\n      available: true,\n      launch: () => this.plugin.launch()\n    }\n\n    if (this.player.captioning != null) {\n      this.captioning = new AmpCafSenderCaptioning(this)\n    }\n\n    this.localization = {\n      getLanguageString: (lang) => this.player.localization.getLanguageString(lang),\n      getString: (key) => this.player.localization.getString(key)\n    }\n\n    const type = this.player.mode\n    const key = \"react\"\n    const def = akamai.amp.AMP.plugins[key][type]\n    const config = this.config.plugins.react\n    config.mode = akamai.amp.react.Mode.PERSISTENT\n\n    if (def == null) {\n      throw new Error(`[AMP] Plugin could not be found: ${key}`)\n    }\n\n    return def(this, config, key)\n      .then((plugin) => {\n        this[key] = plugin\n        if (plugin.feature != null) {\n          this[plugin.feature] = plugin\n        }\n        this.logger.log(`[AMP] Plugin registered: ${key}`)\n      })\n      .catch((error) => this.logger.error(error))\n  }\n\n  onRemotePlayerChange(event) {\n    const type = cast.framework.RemotePlayerEventType\n    const amp = akamai.amp.Events\n\n    switch (event.field) {\n      case \"mediaInfo\":\n        if (event.value) {\n          this.playState = this.remotePlayer.playerState.toLowerCase()\n          this.dispatch(akamai.amp.Events.DURATION_CHANGE, event.value.duration)\n        }\n      break\n\n      case \"currentTime\":\n        if (this.seeking === true) {\n          this.dispatch(akamai.amp.Events.CAN_PLAY_THROUGH)\n          this.dispatch(akamai.amp.Events.SEEKED)\n          this.state.seeking = false\n        }\n\n        if (this.waiting === true) {\n          this.waiting = false\n        }\n\n        this.dispatch(amp.TIME_UPDATE, this.currentTime)\n      break\n\n      case \"duration\":\n        this.dispatch(amp.DURATION_CHANGE, this.duration)\n      break\n\n      case \"volumeLevel\":\n        this.dispatch(amp.VOLUME_CHANGE, this.volume)\n      break\n\n      case \"isMuted\":\n        this.dispatch(amp.VOLUME_CHANGE, (event.value) ? 0 : this.volume)\n        this.dispatch(amp.MUTE_CHANGE, this.muted)\n      break\n\n      case \"playerState\":\n        let state = null\n\n        switch (event.value) {\n          case chrome.cast.media.PlayerState.PLAYING:\n            state = akamai.amp.PlayState.PLAYING\n          break\n\n          case chrome.cast.media.PlayerState.PAUSED:\n            state = akamai.amp.PlayState.PAUSED\n          break\n\n          case chrome.cast.media.PlayerState.BUFFERING:\n            this.waiting = true\n          break\n        }\n\n        if (state) {\n          this.playState = state\n        }\n      break\n    }\n  }\n\n  onMediaSession(event) {\n    if (this.remotePlayerController != null) {\n      this.remotePlayerController.removeEventListener(cast.framework.RemotePlayerEventType.ANY_CHANGE, this.onRemotePlayerChange)\n    }\n    this.remotePlayer = new cast.framework.RemotePlayer()\n    this.remotePlayerController = new cast.framework.RemotePlayerController(this.remotePlayer)\n    this.remotePlayerController.addEventListener(cast.framework.RemotePlayerEventType.ANY_CHANGE, this.onRemotePlayerChange)\n  }\n\n  get mediaElement() {\n    return {}\n  }\n\n  get logger() {\n    return this.plugin.logger\n  }\n\n  set currentTime(value) {\n    if (value == this.state.currentTime) {\n      return\n    }\n\n    this.state.seeking = true\n    this.state.currentTime = value\n    this.remotePlayer.currentTime = value\n    this.remotePlayerController.seek()\n    this.dispatch(akamai.amp.Events.SEEKING)\n  }\n\n  get currentTime() {\n    return this.remotePlayer.currentTime\n  }\n\n  get duration() {\n    return this.remotePlayer.duration\n  }\n\n  set autoplay(value) {\n\n  }\n\n  get autoplay() {\n    return true\n  }\n\n  set media(value) {\n    this.plugin.load(value)\n  }\n\n  get media() {\n    const session = this.plugin.mediaSession\n    return (session != null && session.media.customData != null) ? session.media.customData.media : this.player.media\n  }\n\n  set volume(value) {\n    this.remotePlayer.volumeLevel = value\n    this.remotePlayerController.setVolumeLevel()\n  }\n\n  get volume() {\n    return this.remotePlayer.volumeLevel\n  }\n\n  set muted(value) {\n    this.remotePlayerController.muteOrUnmute()\n  }\n\n  get muted() {\n    return this.remotePlayer.isMuted\n  }\n\n  set playbackRate(value) {\n\n  }\n\n  get playbackRate() {\n    return 1\n  }\n\n  set waiting(value) {\n    if (value == this.state.waiting) {\n      return\n    }\n\n    this.state.waiting = value\n    if (value) {\n      this.dispatch(akamai.amp.Events.WAITING)\n    }\n  }\n\n  get waiting() {\n    return this.state.waiting\n  }\n\n  get seeking() {\n    return this.state.seeking\n  }\n\n  get paused() {\n    return this.remotePlayer.isPaused\n  }\n\n  get ended() {\n    return false\n  }\n\n  set quality(value) {\n    return\n  }\n\n  get quality() {\n    return 0\n  }\n\n  get qualityMode() {\n    return \"auto\"\n  }\n\n  get qualityLevels() {\n    return []\n  }\n\n  get audioTracks() {\n    return []\n  }\n\n  set playState(value) {\n    const previous = this.state.playState\n    if (value == previous) {\n      return\n    }\n    this.state.playState = value\n    this.dispatch(akamai.amp.Events.PLAY_STATE_CHANGE, {previous, value})\n\n    switch (value) {\n      case akamai.amp.PlayState.PLAYING:\n        this.dispatch(akamai.amp.Events.PLAYING)\n      break\n\n      case akamai.amp.PlayState.PAUSED:\n        this.dispatch(akamai.amp.Events.PAUSE)\n      break\n\n      case akamai.amp.PlayState.ENDED:\n        this.dispatch(akamai.amp.Events.ENDED)\n      break\n    }\n  }\n\n  get playState() {\n    return this.state.playState\n  }\n\n  get viewComponent() {\n    return this.container\n  }\n\n  get settings() {\n    return this.player.settings\n  }\n\n  play() {\n    this.remotePlayerController.playOrPause()\n  }\n\n  pause() {\n    this.remotePlayerController.playOrPause()\n  }\n\n  getLocalizedString(value, context) {\n    return this.player.getLocalizedString(value, context)\n  }\n\n  destroy() {\n    if (this.remotePlayerController != null) {\n      this.remotePlayerController.removeEventListener(cast.framework.RemotePlayerEventType.ANY_CHANGE, this.onRemotePlayerChange)\n    }\n    this.plugin.castSession.removeEventListener(cast.framework.SessionEventType.MEDIA_SESSION, this.onMediaSession)\n    this.player.container.removeChild(this.container)\n    this.player.container.removeChild(this.message)\n  }\n}\n","import ChromecastConstants from \"./ChromecastConstants\"\nimport AmpCafSender from \"./AmpCafSender\"\n\nexport default class Chromecast extends akamai.amp.Plugin {\n\n  constructor(player, config) {\n    super(player, config)\n\n    this._available = false\n  }\n\n  onready() {\n    this.bindHandlers([\"onCastApiAvailable\", \"onCastStateChanged\", \"onSessionStateChanged\", \"onMediaSession\"])\n    window['__onGCastApiAvailable'] = this.onCastApiAvailable\n\n    this.player.loadResources(this.config.sdk)\n  }\n\n  get available() {\n    return this._available\n  }\n\n  setAvailable(value) {\n    if (value === this._available) {\n      return\n    }\n\n    this._available = value\n    this.player.dispatch(akamai.amp.Events.PLAYBACK_TARGET_AVAILABILITY_CHANGE, {target: ChromecastConstants.ID, available: value})\n  }\n\n  onCastApiAvailable(isAvailable) {\n    if (!isAvailable) {\n      return\n    }\n\n    this.castContext = cast.framework.CastContext.getInstance()\n\n    this.castContext.addEventListener(cast.framework.CastContextEventType.CAST_STATE_CHANGED, this.onCastStateChanged)\n    this.castContext.addEventListener(cast.framework.CastContextEventType.SESSION_STATE_CHANGED, this.onSessionStateChanged)\n    this.castContext.setOptions({\n      receiverApplicationId: this.config.applicationId,\n      autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED\n    })\n  }\n\n  onCastStateChanged(event) {\n    this.setAvailable((event.castState !== cast.framework.CastState.NO_DEVICES_AVAILABLE))\n  }\n\n  onSessionStateChanged(event) {\n    let mediaSession = null\n\n    switch (event.sessionState) {\n      case cast.framework.SessionState.SESSION_STARTING:\n        this.player.pause()\n        this.player.busy = true\n      break\n\n      case cast.framework.SessionState.SESSION_RESUMED:\n        this.player.busy = true\n        this.castSession = event.session\n        mediaSession = event.session.getMediaSession()\n        if (mediaSession.media && this.player.media) {\n          const sources = (this.player.media.sources || []).map((source) => source.src)\n          sources.push(this.player.media.src)\n          if (sources.includes(mediaSession.media.contentId)) {\n            this.onMediaSession({mediaSession})\n          }\n        }\n      break\n\n      case cast.framework.SessionState.SESSION_STARTED:\n        this.castSession = event.session\n        this.castSession.addEventListener(cast.framework.SessionEventType.MEDIA_SESSION, this.onMediaSession)\n        if (this.castSession.getMediaSession() == null) {\n          this.load(this.player.media, this.player.currentTime)\n        }\n      break\n\n      case cast.framework.SessionState.SESSION_ENDED:\n        mediaSession = event.session.getMediaSession()\n        if (mediaSession != null) {\n          this.player.currentTime = event.session.getMediaSession().currentTime\n        }\n        this.player.playbackTarget = \"amp\"\n      break\n    }\n  }\n\n  onMediaSession(event) {\n    this.mediaSession = event.mediaSession\n    this.player.playbackTarget = ChromecastConstants.ID\n  }\n\n  onplaybacktargetchange(event) {\n    if (event.detail.value === ChromecastConstants.ID) {\n      this.sender = new AmpCafSender(this)\n    }\n    else {\n      if (this.sender != null) {\n        this.sender.destroy()\n      }\n      this.player.busy = false\n    }\n  }\n\n  launch() {\n    this.castContext.requestSession()\n      .catch((error) => {\n        if (error != \"cancel\")\n          this.logger.error(error)\n      })\n  }\n\n  load(media, startTime = 0) {\n\n    if (media == null) {\n      return\n    }\n\n    const source = akamai.amp.Utils.selectSource(media.source, (type) => ChromecastConstants.SUPPORTED_TYPES.includes(type) ? \"maybe\" : \"\")\n\n    if (source == null) {\n      return\n    }\n\n    media.src = source.src\n    media.type = source.type\n\n    const metadata = new chrome.cast.media.GenericMediaMetadata()\n    metadata.title = media.title\n    metadata.subtitle = media.description\n    metadata.image = [new chrome.cast.Image(media.poster)]\n    metadata.releaseDate = (media.pubDate && media.pubDate.toISOString) ? media.pubDate.toISOString() : null\n\n    const mediaInfo = new chrome.cast.media.MediaInfo(source.src, source.type)\n    mediaInfo.duration = media.duration\n    mediaInfo.customData = {media}\n    mediaInfo.metadata = metadata\n\n    if (media.track && media.track.length > 0) {\n      mediaInfo.tracks = []\n      media.track.forEach((value, index) => {\n        const track = new chrome.cast.media.Track(index, chrome.cast.media.TrackType.TEXT)\n        track.subtype = chrome.cast.media.TextTrackType.CAPTIONS\n        track.name = amp.l10n.MSG_CLOSED_CAPTIONING\n        track.language = value.srclang\n        track.customData = value\n        track.trackContentId = value.src\n        track.trackContentType = value.type\n        mediaInfo.tracks.push(track)\n      })\n    }\n\n    const request = new chrome.cast.media.LoadRequest(mediaInfo)\n    request.currentTime = startTime\n\n    this.castSession.loadMedia(request)\n      .catch((error) => this.logger.error(error))\n  }\n}\n","import \"./main.less\"\nimport Chromecast from \"./Chromecast\"\n\nakamai.amp.AMP.registerPlugin(\"chromecast\", akamai.amp.Plugin.createFactory(Chromecast))\n\nexport {Chromecast}\n"]}